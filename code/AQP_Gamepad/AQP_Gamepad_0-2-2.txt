/*

Aq+ Gamepad
--------------------------------------------------------------------------------------------
by Sean P. Harrington
sph@1stage.com
aquarius.1stage.com
--------------------------------------------------------------------------------------------

Abstract -
The Aq+ Gamepad is a modern game controller for Aquarius and Aquarius+ 8-bit Z80-based 
computers. It features either wired (Mini/Micro/MX expander required for original Aquarius)
or wireless (Aquarius+) connectivity, and emulates the original Aquarius hand controller in
a form-factor that is more comfortable and fun to use.

The system was developed using an ESP32-S3-DevKitC module as the microcontroller and BLE 
(Bluetooth Low Energy) as the wireless solution. It is configured using the Arduino Core, 
and uses the "ESP32-S3-Box" board profile. Additionally, BLE connectivity is coded using 
the ESP32-BLE-Gamepad library, which itself relies on the NimBLE-Arduino library. The RGB 
LED serves as a system status indicator and uses the Adafruit NeoPixel library. All libraries 
can be loaded through the Arduino Library Manager. The system also features a LiPo 
(lithium polymer) battery, with smart charging.

--------------------------------------------------------------------------------------------

To-Do List:
 - State machine for RGB LED visual notifications
   - Charging, low battery, full, etc.
   - Paired, wired, inactive, etc.
   - Blinks for some statuses initiated by chorded button/thumbstick sequences
 - Create Preferences (NVS data) for serial number, settings, etc.
 - USB serial/terminal interface for setting preferences (web, eventually?)
 - Create editable trim values for analog sensors
   - XY homing, and "dead zone"
   - Battery level (BATTDIV)
 - Add ability to toggle DPAD/HAT wireless output?
 - Add ability to toggle/swap 1-2-3 & 4-5-6 button rows.

Revisions:
0.3.0, 22 FEB 2025 -  Incorporate Preferences for NVS data
0.2.2, 21 FEB 2025 -  Fix XY dead zone issues
                      Commented code
                      Turn all main loop processes into funtions
                      Created TRIM variables for thumb stick
0.2.1, 18 FEB 2025 -  Fix NeoPixel error
0.2.0, 12 FEB 2025 -  Added 1+3+5 wired chord to AQ button and changed it from BUTTON_13 to BUTTON_12 in wireless
0.1.9, 03 DEC 2024 -  Created state machine for LED/Battery
0.1.8, 30 NOV 2024 -  Remapped GPIO pin assignments after PCB rework
0.1.7, 19 NOV 2024 -  Added SettingsManagerESP32 to save persistent variables (replaces legacy EEPROM.h libarary)
0.1.6, 17 NOV 2024 -  Added battery divider sense pin
0.1.5, 17 NOV 2024 -  Switched to GPIO rather than Shift Register
0.1.4, 16 NOV 2024 -  Rework analog angle calculations from Aq+ ESP32 code
                      Created buttonByte and thumbByte to combine into dataByte
0.1.3, 11 NOV 2024 -  Shift register implemented for wired connections
                      Turn button components into arrays and loop
0.1.2, 09 NOV 2024 -  Button alignment with Xbox mappings
                      Thumbstick scaling fixed
                      Buttons transitioned to single-pin (from matrix)
0.1.1, 08 NOV 2024 -  Button matrix (unsuccessful)
0.1.0, 07 NOV 2024 -  Initial version, using Gamepad example (four buttons)
                      Installed Arduino bootloader
                      Identified compatible Board profile (ESP32-S3-Box)

Links & References -
AQP Gamepad GitHub: https://github.com/1stage/aqplus-controller
ESP32-S3_DevKitC: https://docs.espressif.com/projects/esp-dev-kits/en/latest/esp32s3/esp32-s3-devkitc-1/index.html
Arduino Core for ESP32: https://github.com/espressif/arduino-esp32
ESP32-BLE-Gamepad: https://github.com/lemmingDev/ESP32-BLE-Gamepad
Adafruit NeoPixel: https://github.com/adafruit/Adafruit_NeoPixel
NimBLE Arduino: https://github.com/h2zero/NimBLE-Arduino
SettingsManagerESP32: https://github.com/alkonosst/SettingsManagerESP32

*/

#include <Arduino.h>
#include <Adafruit_NeoPixel.h>
#include <BleGamepad.h>
#include <BleGamepadConfiguration.h>
#include <math.h>
#include <Preferences.h>

#define BUTTONPIN_1 5   // ESP32 GPIO pin Aq+ button 1 is attached to
#define BUTTONPIN_2 6   // ESP32 GPIO pin Aq+ button 2 is attached to
#define BUTTONPIN_3 7   // ESP32 GPIO pin Aq+ button 3 is attached to
#define BUTTONPIN_4 8   // ESP32 GPIO pin Aq+ button 4 is attached to
#define BUTTONPIN_5 9   // ESP32 GPIO pin Aq+ button 5 is attached to
#define BUTTONPIN_6 10  // ESP32 GPIO pin Aq+ button 6 is attached to
#define BUTTONPIN_T 4   // ESP32 GPIO pin Aq+ thumbstick button is attached to
#define BUTTONPIN_G 11  // ESP32 GPIO pin Aq+ guide button is attached to

#define XPIN 15  // ESP32 GPIO pin thumbstick X is attached to
#define YPIN 16  // ESP32 GPIO pin thumbstick Y is attached to

#define BATTDIV 13  // Pin to read battery voltage level

#define RGBPIN 48  // ESP32 GPIO pin RGB LED data is attached to
#define NUMPIX 1   // Number of NeoPixel units

#define DATAPIN_0 39  // Wired data out pin 0
#define DATAPIN_1 38  // Wired data out pin 1
#define DATAPIN_2 21  // Wired data out pin 2
#define DATAPIN_3 18  // Wired data out pin 3
#define DATAPIN_4 40  // Wired data out pin 4
#define DATAPIN_5 41  // Wired data out pin 5
#define DATAPIN_6 42  // Wired data out pin 6
#define DATAPIN_7 17  // Wired data out pin 7

#define AQGP_NAME "Aq+ Gamepad"
#define AQGP_MNFR "1STAGE"
#define AQGP_BATT 100
#define AQGP_MODL "1.0"
#define AQGP_SWFM "0.2.2"
#define AQGP_HWRV "rev0"
#define AQGP_SRLN "AQGP-xxx-SPH"

// Create a NeoPixel object to control
Adafruit_NeoPixel pixels(NUMPIX, RGBPIN, NEO_GRB + NEO_KHZ800);

// Create a BleGamepad object to control
BleGamepad aqpGamepad(AQGP_NAME, AQGP_MNFR, AQGP_BATT);

// Create a BleGamepadConfiguration object to store all of the options
BleGamepadConfiguration aqpGamepadConfig;

// Create a state change history for all 8 buttons.
// buttonState[button_num][previous, current], HIGH = OFF
int buttonState[8][2] = { { HIGH, HIGH },
                          { HIGH, HIGH },
                          { HIGH, HIGH },
                          { HIGH, HIGH },
                          { HIGH, HIGH },
                          { HIGH, HIGH },
                          { HIGH, HIGH },
                          { HIGH, HIGH } };

// Create an LED RGB color data structure
struct ledColor {
  int ledR;
  int ledG;
  int ledB;
};

ledColor RED     = { 32,  0,  0 };
ledColor GREEN   = {  0, 32,  0 };
ledColor BLUE    = {  0,  0, 32 };
ledColor CYAN    = {  0, 32, 32 };
ledColor YELLOW  = { 32, 32,  0 };
ledColor MAGENTA = { 32,  0, 32 };
ledColor BLACK   = {  0,  0,  0 };
ledColor WHITE   = { 32, 32, 32 };
ledColor ORANGE  = { 32, 16,  0 };

// Create state memory for battery level: batteryState[previous, current]
int batteryState[2] = { 1, 1 };

// Create state memory for connectivity: connectState[previous, current]
int connectState[2] = { 1, 1 };

// Combined state memory for battery & connectivity: battConState[previous, current]
int battConState[2] = { 1, 1 };

// Create a state change history for the thumbstick: thumbState[previous, current]
int thumbState[2]   = { 0, 0 };

// Create a data pin array for wired output.
int dataPins[8] = { DATAPIN_0,
                    DATAPIN_1,
                    DATAPIN_2,
                    DATAPIN_3,
                    DATAPIN_4,
                    DATAPIN_5,
                    DATAPIN_6,
                    DATAPIN_7 };

// Create an array mapping between Aquarius buttons and BLE Gamepad buttons.
// buttonPinMap[button_num][Aq+ Button Pin, GP button]
uint8_t buttonPinMap[8][2] = { { BUTTONPIN_1, BUTTON_1 },
                               { BUTTONPIN_2, BUTTON_2 },
                               { BUTTONPIN_3, BUTTON_4 },
                               { BUTTONPIN_4, BUTTON_5 },
                               { BUTTONPIN_5, BUTTON_7 },
                               { BUTTONPIN_6, BUTTON_8 },
                               { BUTTONPIN_T, BUTTON_11 },
                               { BUTTONPIN_G, BUTTON_12 } }; // Was BUTTON_13

// Create an array for the data mappings for
// the wired output (byte mapping) for the 8 buttons.
uint8_t buttonByte[8] = { 0b01000000,
                          0b10000100,
                          0b10100000,
                          0b00100000,
                          0b10000010,
                          0b10000001,
                          0b11111111,
                          0b11100010 }; // Was 0b00000000

// Create an array for the data mappings for
// the wired output (byte mapping0 for the 16 thumbstick values
uint8_t thumbByte[17] = { 0b00000000,
                          0b00000010,
                          0b00010010,
                          0b00010011,
                          0b00000011,
                          0b00000001,
                          0b00010001,
                          0b00011001,
                          0b00001001,
                          0b00001000,
                          0b00011000,
                          0b00011100,
                          0b00001100,
                          0b00000100,
                          0b00010100,
                          0b00010110,
                          0b00000110 };


// Number of thumbstick samples to take per cycle
const int thumbSamples = 5;

// Battery level variables
const int battSamples  = 10;  // Number of battery samples to take per cycle
const int delaySamples = 2;   // Delay in milliseconds between samples
int battValues[battSamples];  // Holder array for battery samples
int rawBatt;                  // Holder for raw battery level reading on ESP32 analog GPIO
uint8_t battLevel = 100;      // Starting battery level, updated from BATTDIV reading in main loop

// Persistent holder for new button data
uint8_t buttonOut = 0b00000000;
// Persistent holder for new thumbstick data
uint8_t thumbOut  = 0b00000000;
// Per-cycle holder for combined button and thumbstick data sent to data out pins
uint8_t dataOut   = 0b00000000;

// Default multiplier for milliseconds
int timeScaler = 2;
// Wait time in millis() between LED updates
int cycleLEDWait = battLevel * timeScaler;
// Holder for LED pulse animation update timer
unsigned long cycleLED = millis() + cycleLEDWait;
// LED animation holder
int counterLED = 1;

// Holder for LED color, set to BLACK / OFF
ledColor theLED = BLACK;

// Additional thumbstick variables
int XTrim;                  // Trim adjustment (per device) for rawX value
int YTrim;                  // Trim adjustment (per device) for rawY value
int XValues[thumbSamples];  // Holder array for X samples
int YValues[thumbSamples];  // Holder array for Y samples
int XValue;                 // Normalized X value from samples
int YValue;                 // Normalized Y value from samples
int adjXValue;              // Scaled X value for Gamepad value range
int adjYValue;              // Scaled Y value for Gamepad value range
int dirXValue;              // Scaled X value for trigonometric value range
int dirYValue;              // Scaled Y value for trigonometric value range
float x;                    // X value / 180 for finding 16 direction range
float y;                    // Y value / 180 for finding 16 direction range
float deadZone;             // Holder for mapping the center dead zone to reduce jitters
float dzFactor = 1.0;       // The acceptable area for thumbstick jitter: 1.0 is standard; 1.1 is less sensitive, etc.
float angle;                // Holder for angle value for 16 direction mapping

// Set up the system
void setup() {

  // Turn on the serial port.
  Serial.begin(115200);

  // Get the saved unit data and publish it to the AQP Gamepad config.
  aqpGamepadConfig.setModelNumber(AQGP_MODL);
  aqpGamepadConfig.setSoftwareRevision(AQGP_SWFM);
  aqpGamepadConfig.setFirmwareRevision(AQGP_SWFM);
  aqpGamepadConfig.setSerialNumber(AQGP_SRLN);
  aqpGamepadConfig.setHardwareRevision(AQGP_HWRV);

  // Set all GPIO button pins [x][0] to INPUT_PULLUP
  // and all wired output dataPins[x] to OUTPUT.
  for (int i = 0; i < 8; i++) {
    pinMode(buttonPinMap[i][0], INPUT_PULLUP);
    pinMode(dataPins[i], OUTPUT);
  }

  // Set the battery level sensor to input (analog).
  pinMode(BATTDIV, INPUT);

  // Set the X and Y pots on the thumbstick to input (analog).
  pinMode(XPIN, INPUT);
  pinMode(YPIN, INPUT);

  // Start the BLE Gamepad.
  aqpGamepad.begin();

  // Send data (blank, at start) to the wired connection.
  shiftOut(dataOut);

  // Set the initial battery level (100%).
  // It will be read and updated in the main loop.
  aqpGamepad.setBatteryLevel(battLevel);

  // Setup the LED cycle timer.
  cycleLED = millis() + cycleLEDWait;

  checkBattery();
  checkConnect();
  calcRGB();

  // Start up the RGB LED.
  pixels.begin();
  pixels.clear();
  theLED = CYAN;
  updateNeoPixel();

  // Set X & Y Trim values
  XTrim = 92;
  YTrim = 110;
}

// Main cycle loop
void loop() {

  dataOut = 0b00000000;     // Reset outbound data register each cycle
                            // Note that buttonOut and thumbOut persist through cycle loops

  checkButtons();           // Read buttons and update wireless connection
  checkThumbs();            // Read thumbstick and update wireless connection
  shiftOut(dataOut);        // Write data for buttons and thumbsticks to wired connection

  // Check battery level every 1 second at the .9 second mark
  if (millis() % 1000 > 900) {
    checkBattery();
  }

  // Check BTLE connection every 1 second at the .8 second mark
  if (((millis() % 1000) > 800) & ((millis() % 1000) <= 900)) {
    checkConnect();
  }

  setState();               // Set system state for battery and wireless
  calcRGB();                // Calculate the RGB LED color and pulse rate from system state
  updateNeoPixel();         // Update NeoPixel RGB LED

  debugOut();               // Send diagnostic data out serial connection
}

// Send diagnostics out serial connection
void debugOut() {
  Serial.print("dataOut=");                 // Bit value being sent out the wired connection (1 = ON, LOW ; 0 = OFF, HIGH)
  Serial.print(dataOut+256, BIN);
  Serial.print(" : rawX=");                 // Raw X value (0-5119) as read by the ESP32 analog GPIO
  Serial.print(XValue);
  Serial.print(" : adjX=");                 // Adjusted X value (0-32730) in the range needed by Gamepad BLE
  Serial.print(adjXValue);
  Serial.print(" : rawY=");                 // Raw Y value (0-5119) as read by the ESP32 analog GPIO
  Serial.print(YValue);
  Serial.print(" : adjY=");                 // Adjusted Y value (0-32730) in the range needed by Gamepad BLE
  Serial.print(adjYValue);
  Serial.print(" : rawBatt=");              // Raw battery level as read by the ESP32 analog GPIO
  Serial.print(rawBatt);
  Serial.print(" : bLevel=");               // Scaled battery level (0-100)
  Serial.print(battLevel);
  Serial.print(" : BTLE=");                 // Bluetooth LE connection status (0 disconnected, 1 connected)
  Serial.print(aqpGamepad.isConnected());
  Serial.print(" : bcState=");              // Combined battery + connection status integer: (battery state * 10) + connection state
  Serial.print(battConState[1]);
  Serial.println();

  // Serial.print(F("String")); // Print from string stored in FLASH memory. Save for later memory management clean-up.
}

// Loop through the 8 buttons, check for changes, and apply updates
void checkButtons() {
  // buttonState[button_num][0 prev, 1 curr]
  // buttonPinMap[button_num][0 GPIO, 1 GP Map]
  for (int i = 0; i < 8; i++) {
    // Set button's current logical state to its current physical state
    buttonState[i][1] = digitalRead(buttonPinMap[i][0]);
    // If the current state is different from its last state...
    if (buttonState[i][1] != buttonState[i][0]) {
      // ...if its current state is PRESSED...
      if (buttonState[i][1] == LOW) {
        // ...if there is a BLE connection, update that...
        if (aqpGamepad.isConnected()) { aqpGamepad.press(buttonPinMap[i][1]); };
        // ...and combine the previous button data with this button's data.
        buttonOut |= buttonByte[i];
      } else {
        // Otherwise its current state is RELEASED, so
        // if there is a BLE connection, update that...
        if (aqpGamepad.isConnected()) { aqpGamepad.release(buttonPinMap[i][1]); };
        // ...and remove this button's data from the previous button data.
        buttonOut &= ~buttonByte[i];
      }
    }
    // Set the previous button state to the current one.
    buttonState[i][0] = buttonState[i][1];
  }
  
  // Combine button data into wired data output.
  // (Wired data was blanked at the top of the main loop.)
  dataOut |= buttonOut;
}

// Read the sample values from the thumbsticks and update
void checkThumbs() {

  // Loop to sample the thumb stick a number of times
  // and normalize the value by averaging the samples
  for (int i = 0; i < thumbSamples; i++) {
    XValues[i] = analogRead(XPIN) + XTrim;
    YValues[i] = analogRead(YPIN) + YTrim;
    XValue += XValues[i];
    YValue += YValues[i];
    delay(delaySamples);
  }

  // Average samples
  XValue = XValue / thumbSamples;
  YValue = YValue / thumbSamples;

  // Scale thumbstick values to Gamepad BLE range, taking into account trim values
  adjXValue = map(XValue, 0, 5119, 0, 32737);
  adjYValue = map(YValue, 0, 5119, 0, 32737);

  // Set aqpGamepad thumbstick values
  if (aqpGamepad.isConnected()) {
    aqpGamepad.setX(adjXValue);
    aqpGamepad.setY(adjYValue);
  };

  // Scale thumbstick X & Y values to a positive/negative
  // range for performing the trigonometric calculations
  dirXValue = map(XValue, 0, 5119, -2048, 2048);
  dirYValue = map(YValue, 0, 5119, -2048, 2048);

  // Further scale X & Y values to a range of 32 values
  // for determining which of the 16 direction segments
  // they fall within.
  x = dirXValue / 128.0f;
  y = dirYValue / 128.0f;

  // Update the "dead zone" the middle of the thumbstick
  // when no input is being provided.
  deadZone = sqrtf(x * x + y * y);
  // Update the degree holder (0-359) the angle.
  angle = 0;
  // Create a variable to hold the 16 segment sector the
  // thumbstick is positioned within. The default of 0
  // indicates it's in the "dead zone".
  int p = 0;

  // Check to make sure the thumbstick is outside the "dead zone".
  if (deadZone > dzFactor) {
    // Calculate the angle and scale it.
    angle = atan2f(y, x) / (float)M_PI * 180.0f + 180.0f;
    // Calculate the sector and scale it to 1-16 using the "middle" of the angle range
    p = ((int)((angle + 11.25) / 22.5f) + 8) % 16 + 1;
  }

  // Set the current thumbstick state to the sector
  thumbState[1] = p;
  // If this is different from the previous sector...
  if (thumbState[1] != thumbState[0]) {
    // ...update the thumbstick output. Note that there is
    // no blending of this data from the previous state
    thumbOut = thumbByte[thumbState[1]];
    // Set the previous thumbstick sector to the current
    thumbState[0] = p;
  }

  // Combine thumbstick data with the already combined button data
  dataOut |= thumbOut;
}

// Checks the state of the battery
void checkBattery() {

  // Loop to sample the battery a number of times
  // and normalize the value by averaging the samples
  for (int i = 0; i < battSamples; i++) {
    battValues[i] = analogRead(BATTDIV);
    rawBatt += battValues[i];
    delay(delaySamples);
  }

  // Average the values for normalization...
  rawBatt = int (rawBatt / battSamples);
  // ...and scale it to an expected 1-100 range
  battLevel = map(rawBatt, 0, 3267, 1, 100);

  // Publish this to the BLE Gamepad.
  if (aqpGamepad.isConnected()) {
    aqpGamepad.setBatteryLevel(battLevel);
  }

  // If the battery is 50-100%...
  if (battLevel > 49) {
    batteryState[1] = 1;
  }
  // If the battery is between 25-49%...
  if ((battLevel < 50) && (battLevel > 24)) {
    batteryState[1] = 2;
  }
  // If the battery is between 10-24%...
  if ((battLevel < 25) && (battLevel > 9)) {
    batteryState[1] = 3;
  }
  // If the battery is below 10%...
  if (battLevel < 10) {
    batteryState[1] = 4;
  }

  // Update previous state to current state.
  batteryState[0] = batteryState[1];
}

// Checks the state of connectivity
void checkConnect() {
  // If BLE is connected...
  if (aqpGamepad.isConnected()) {
    connectState[1] = 2;
  } else {
    connectState[1] = 1;
  }
  // Update previous state to current state.
  connectState[0] = connectState[1];
}

// Set battery and connectivity state
void setState() {
  // Combine battery and connect states into one number.
  battConState[1] = (batteryState[1] * 10) + connectState[1];

  // Update previous states with current states.
  battConState[0] = battConState[1];
}

// Calculates current color & pulse rate of LED
void calcRGB() {
  cycleLEDWait = battLevel * timeScaler;

  // Process every possible combination of states.
  switch (battConState[1]) {
    // Batt 50-100%, BLE NOT connected
    // Set color to a solid MAGENTA
    case 11:
      theLED = CYAN;
      break;
    // Batt 50-100%, BLE connected
    // Set color to a solid BLUE
    case 12:
      theLED = BLUE;
      break;

    // Batt 25-49%, BLE NOT connected
    // Pulse MAGENTA to BLACK to MAGENTA
    case 21:
      if (millis() >= cycleLED) {
        // See if we're at the "bottom" of the pulse cycle...
        if (theLED.ledB < 1) {
          theLED = BLACK;
          // ...and send it in the positive direction.
          counterLED = 1;
        }
        // Then see if we're at the "top" of the pulse cycle...
        if (theLED.ledB > 32) {
          theLED = MAGENTA;
          // ...and send it in the negative direction.
          counterLED = -1;
        }
        theLED.ledR += counterLED;
        theLED.ledG = 0;
        theLED.ledB += counterLED;
        cycleLED = millis() + cycleLEDWait;
      }
      break;

    // Batt 25-49%, BLE connected
    // Pulse BLUE to BLACK TO BLUE
    case 22:
      if (millis() >= cycleLED) {
        // See if we're at the "bottom" of the pulse cycle...
        if (theLED.ledB < 1) {
          theLED = BLACK;
          // ...and send it in the positive direction.
          counterLED = 1;
        }
        // Then see if we're at the "top" of the pulse cycle...
        if (theLED.ledB > 32) {
          theLED = BLUE;
          // ...and send it in the negative direction.
          counterLED = -1;
        }
        theLED.ledR = 0;
        theLED.ledG = 0;
        theLED.ledB += counterLED;
        cycleLED = millis() + cycleLEDWait;
      }
      break;

    // Batt 10-24%, BLE NOT connected
    // Pulse MAGENTA to BLACK to MAGENTA
    case 31:
      if (millis() >= cycleLED) {
        // See if we're at the "bottom" of the pulse cycle...
        if (theLED.ledB < 1) {
          theLED = BLACK;
          // ...and send it in the positive direction.
          counterLED = 1;
        }
        // Then see if we're at the "top" of the pulse cycle...
        if (theLED.ledB > 32) {
          theLED = MAGENTA;
          // ...and send it in the negative direction.
          counterLED = -1;
        }
        theLED.ledR += counterLED;
        theLED.ledG = 0;
        theLED.ledB += counterLED;
        cycleLED = millis() + cycleLEDWait;
      }
      break;

    // Batt 10-24%, BLE connected
    // Pulse BLUE to BLACK to BLUE
    case 32:
      if (millis() >= cycleLED) {
        // See if we're at the "bottom" of the pulse cycle...
        if (theLED.ledB < 1) {
          theLED = BLACK;
          // ...and send it in the positive direction.
          counterLED = 1;
        }
        // Then see if we're at the "top" of the pulse cycle...
        if (theLED.ledB > 32) {
          theLED = BLUE;
          // ...and send it in the negative direction.
          counterLED = -1;
        }
        theLED.ledR = 0;
        theLED.ledG = 0;
        theLED.ledB += counterLED;
        cycleLED = millis() + cycleLEDWait;
      }
      break;

    // Battery <10% or other untrapped errors
    // Set timer to pulse RED to BLACK to RED
    default:
      if (millis() >= cycleLED) {
        // See if we're at the "bottom" of the pulse cycle...
        if (theLED.ledR < 1) {
          theLED = BLACK;
          // ...and send it in the positive direction.
          counterLED = 1;
        }
        // Then see if we're at the "top" of the pulse cycle...
        if (theLED.ledR > 32) {
          theLED = RED;
          // ...and send it in the negative direction.
          counterLED = -1;
        }
        theLED.ledR += counterLED;
        theLED.ledG = 0;
        theLED.ledB = 0;
        cycleLED = millis() + cycleLEDWait;
      }
      break;
  }
}

// Update the NeoPixel RGB LED
void updateNeoPixel() {
  // Update the RGB LED values...
  pixels.setPixelColor(0, theLED.ledR, theLED.ledG, theLED.ledB);
  // ...and publish them to the device.
  pixels.show();
}

// Takes a byte and assigns its bits to individual GPIO pins for the wired connection.
void shiftOut(byte myDataOut) {
  // Start at the MSB/high bit, and work down.
  for (int i = 7; i >= 0; i--) {

    // This next section may seem contradictory, but the myDataOut bits
    // represent a byte in traditional binary format, where 1=ON/HIGH/TRUE
    // and 0=OFF/LOW/FALSE, but they are presented electronically on the
    // GPIO pins in the inverse, where 1=OFF/LOW/FALSE and 0=ON/HIGH/TRUE.

    // So, if the saved bit and current bit are 1...
    if (myDataOut & (1 << i)) {
      // ...set that GPIO pin/bit to LOW.
      digitalWrite(dataPins[i], LOW);
      // Otherwise...
    } else {
      // ...set that GPIO pin/bit to HIGH.
      digitalWrite(dataPins[i], HIGH);
    }
  }
}
