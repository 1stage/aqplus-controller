/*

Aq+ Gamepad
--------------------------------------------------------------------------------------------
by Sean P. Harrington
sph@1stage.com
aquarius.1stage.com
--------------------------------------------------------------------------------------------

Abstract -
The Aq+ Gamepad is a modern game controller for Aquarius and Aquarius+ 8-bit Z80-based 
computers. It features either wired (Mini/Micro/MX expander required for original Aquarius)
or wireless (Aquarius+) connectivity, and emulates the original Aquarius hand controller in
a form-factor that is more comfortable and fun to use.

The system was developed using an ESP32-S3-DevKitC module as the microcontroller and BLE 
(Bluetooth Low Energy) as the wireless solution. It is configured using the Arduino Core, 
and uses the "ESP32-S3-Box" board profile. Additionally, BLE connectivity is coded using 
the ESP32-BLE-Gamepad library, which itself relies on the NimBLE-Arduino library. The RGB 
LED serves as a system status indicator and uses the Adafruit NeoPixel library. All libraries 
can be loaded through the Arduino Library Manager. The system also features a LiPo 
(lithium polymer) battery, with smart charging.

--------------------------------------------------------------------------------------------

Revisions:
0.1.4, 16 NOV 2024 -  Rework analog angle calculations from Aq+ ESP32 code
                      Created buttonByte and thumbByte to blend into dataByte
0.1.3, 11 NOV 2024 -  Shift register implemented for wired connections
                      Turn button components into arrays and loop
0.1.2, 09 NOV 2024 -  Button alignment with Xbox mappings
                      Thumbstick scaling fixed
                      Buttons transitioned to single-pin (from matrix)
0.1.1, 08 NOV 2024 -  Button matrix (unsuccessful)
0.1.0, 07 NOV 2024 -  Initial version, using Gamepad example (four buttons)
                      Installed Arduino bootloader
                      Identified compatible Board profile (ESP32-S3-Box)

Links & References -
AQP Gamepad GitHub: https://github.com/1stage/aqplus-controller
ESP32-S3_DevKitC: https://docs.espressif.com/projects/esp-dev-kits/en/latest/esp32s3/esp32-s3-devkitc-1/index.html
Arduino Core for ESP32: https://github.com/espressif/arduino-esp32
ESP32-BLE-Gamepad: https://github.com/lemmingDev/ESP32-BLE-Gamepad
Adafruit NeoPixel: https://github.com/adafruit/Adafruit_NeoPixel
NimBLE Arduino: https://github.com/h2zero/NimBLE-Arduino

*/

#include <Arduino.h>
#include <Adafruit_NeoPixel.h>
#include <BleGamepad.h>
#include <BleGamepadConfiguration.h>
#include <math.h>

#define BUTTONPIN_1 5   // ESP32 GPIO pin Aq+ button 1 is attached to
#define BUTTONPIN_2 6   // ESP32 GPIO pin Aq+ button 2 is attached to
#define BUTTONPIN_3 7   // ESP32 GPIO pin Aq+ button 3 is attached to
#define BUTTONPIN_4 8   // ESP32 GPIO pin Aq+ button 4 is attached to
#define BUTTONPIN_5 9   // ESP32 GPIO pin Aq+ button 5 is attached to
#define BUTTONPIN_6 10  // ESP32 GPIO pin Aq+ button 6 is attached to
#define BUTTONPIN_T 4   // ESP32 GPIO pin Aq+ thumbstick button is attached to
#define BUTTONPIN_G 11  // ESP32 GPIO pin Aq+ guide button is attached to

#define XPIN 15  // ESP32 GPIO pin thumbstick X is attached to
#define YPIN 16  // ESP32 GPIO pin thumbstick Y is attached to

#define RGBPIN 48  // ESP32 GPIO pin RGB LED data is attached to
#define NUMPIX 1   // Number of NeoPixel units

#define SR_DATA 12   // ESP32 GPIO pin Shift Register Data pin is attached to
#define SR_CLK 13    // ESP32 GPIO pin Shift Register Clock pin is attached to
#define SR_LATCH 14  // ESP32 GPIO pin Shift Register Latch pin is attached to

#define AQGP_NAME "Aq+ Gamepad"
#define AQGP_MNFR "1STAGE"
#define AQGP_BATT 100
#define AQGP_MODL "1.0"
#define AQGP_SWFM "0.1.4"
#define AQGP_HWRV "rev0"
#define AQGP_SRLN "AQGP-xxx-SPH"

Adafruit_NeoPixel pixels(NUMPIX, RGBPIN, NEO_GRB + NEO_KHZ800);  // Create a NeoPixel object to control

BleGamepad bleGamepad(AQGP_NAME, AQGP_MNFR, AQGP_BATT);  // Create a BleGamepad object to control

BleGamepadConfiguration bleGamepadConfig;  // Create a BleGamepadConfiguration object to store all of the options

unsigned long cycleButtons;        // Timer to clear Buttons
const int cycleButtonsWait = 250;  // Wait time between Buttons

// buttonState[button_num][previous, current], HIGH = OFF
int buttonState[8][2] = { { HIGH, HIGH },
                          { HIGH, HIGH },
                          { HIGH, HIGH },
                          { HIGH, HIGH },
                          { HIGH, HIGH },
                          { HIGH, HIGH },
                          { HIGH, HIGH },
                          { HIGH, HIGH } };

// thumbState[previous, current]
int thumbState[2] = { 0, 0 };

// buttonPinMap[button_num][Aq+ Button Pin, GP button]
uint8_t buttonPinMap[8][2] = { { BUTTONPIN_1, BUTTON_1 },
                               { BUTTONPIN_2, BUTTON_2 },
                               { BUTTONPIN_3, BUTTON_4 },
                               { BUTTONPIN_4, BUTTON_5 },
                               { BUTTONPIN_5, BUTTON_7 },
                               { BUTTONPIN_6, BUTTON_8 },
                               { BUTTONPIN_T, BUTTON_11 },
                               { BUTTONPIN_G, BUTTON_13 } };

// byte mappings for buttons
uint8_t buttonByte[8] = { 0b01000000,
                          0b10000100,
                          0b10100000,
                          0b00100000,
                          0b10000010,
                          0b10000001,
                          0b11111111,
                          0b00000000 };

// byte mappings for thumbstick values
uint8_t thumbByte[17] = { 0b00000000,
                          0b00000010,
                          0b00010010,
                          0b00010011,
                          0b00000011,
                          0b00000001,
                          0b00010001,
                          0b00011001,
                          0b00001001,
                          0b00001000,
                          0b00011000,
                          0b00011100,
                          0b00001100,
                          0b00000100,
                          0b00010100,
                          0b00010110,
                          0b00000110 };

unsigned long cycleThumb;        // Reset timer to clear Thumb
const int cycleThumbWait = 250;  // Wait time between Thumb cycles

const int thumbSamples = 5;  // Number of thumbstick samples to take
const int delaySamples = 4;  // Delay in milliseconds between samples

uint8_t buttonOut = 0b00000000;  // New button data
uint8_t thumbOut = 0b00000000;   // New thumbstick data
uint8_t dataOut = 0b00000000;    // data sent to shift register

unsigned long cycleLED;       // LED animation update timer
const int cycleLEDWait = 50;  // Wait time between LED cycles
int counterLED = 1;

uint8_t ledR = 0;
uint8_t ledG = 0;
uint8_t ledB = 0;

void setup() {

  bleGamepadConfig.setModelNumber(AQGP_MODL);
  bleGamepadConfig.setSoftwareRevision(AQGP_SWFM);
  bleGamepadConfig.setFirmwareRevision(AQGP_SWFM);
  bleGamepadConfig.setSerialNumber(AQGP_SRLN);
  bleGamepadConfig.setHardwareRevision(AQGP_HWRV);

  // Set all GPIO button pins [x][0] to INPUT_PULLUP
  for (int i = 0; i < 8; i++) {
    pinMode(buttonPinMap[i][0], INPUT_PULLUP);
  }

  pinMode(XPIN, INPUT);
  pinMode(YPIN, INPUT);

  pinMode(SR_DATA, OUTPUT);
  pinMode(SR_CLK, OUTPUT);
  pinMode(SR_LATCH, OUTPUT);

  bleGamepad.begin();

  // Hold latch pin LOW while transmitting
  digitalWrite(SR_LATCH, LOW);
  // Send data
  shiftOut(SR_DATA, SR_CLK, dataOut);
  // Set latch pin HIGH when done
  digitalWrite(SR_LATCH, HIGH);
  // Save latched data

  cycleButtons = millis() + cycleButtonsWait;
  cycleThumb = millis() + cycleThumbWait;

  cycleLED = millis() + cycleLEDWait;
  pixels.begin();
  pixels.clear();
  pixels.setPixelColor(0, pixels.Color(ledR, ledG, ledB));
  pixels.show();
}

void loop() {

  dataOut = 0b00000000;

  checkLED();

  // buttonState[button_num][0 prev, 1 curr]
  // buttonPinMap[button_num][0 GPIO, 1 GP Map]
  for (int i = 0; i < 8; i++) {
    buttonState[i][1] = digitalRead(buttonPinMap[i][0]);
    if (buttonState[i][1] != buttonState[i][0]) {
      if (buttonState[i][1] == LOW) {
        if (bleGamepad.isConnected()) { bleGamepad.press(buttonPinMap[i][1]); };
        buttonOut |= buttonByte[i];
      } else {
        if (bleGamepad.isConnected()) { bleGamepad.release(buttonPinMap[i][1]); };
        buttonOut &= ~buttonByte[i];
      }
    }
    buttonState[i][0] = buttonState[i][1];
  }

  int XValues[thumbSamples];
  int YValues[thumbSamples];
  int XValue = 0;
  int YValue = 0;

  for (int i = 0; i < thumbSamples; i++) {
    XValues[i] = analogRead(XPIN);
    YValues[i] = analogRead(YPIN);
    XValue += XValues[i];
    YValue += YValues[i];
    delay(delaySamples);
  }

  XValue = XValue / thumbSamples;
  YValue = YValue / thumbSamples;

  int adjXValue = map(XValue, 0, 4095, 0, 32737);
  int adjYValue = map(YValue, 0, 4095, 0, 32737);

  if (bleGamepad.isConnected()) {
    bleGamepad.setX(adjXValue);
    bleGamepad.setY(adjYValue);
  };

  int dirXValue = map(XValue, 0, 4095, -2048, 2048);
  int dirYValue = map(YValue, 0, 4095, -2048, 2048);

  float x = dirXValue / 128.0f;
  float y = dirYValue / 128.0f;

  float len = sqrtf(x * x + y * y);
  float angle = 0;
  int p = 0;

  if (len > 1.0f) {
    angle = atan2f(y, x) / (float)M_PI * 180.0f + 180.0f;
    p = ((int)((angle + 11.25) / 22.5f) + 8) % 16 + 1;
  }

  // thumbState[0 prev, 1 curr]
  thumbState[1] = p;
  if (thumbState[1] != thumbState[0]) {
    thumbOut = thumbByte[thumbState[1]];
    thumbState[0] = p;
  }

  // Blend button and thumbstick data
  dataOut |= buttonOut;
  dataOut |= thumbOut;

  // Hold latch pin LOW while transmitting
  digitalWrite(SR_LATCH, LOW);
  // Send data
  shiftOut(SR_DATA, SR_CLK, dataOut);
  // Set latch pin HIGH when done
  digitalWrite(SR_LATCH, HIGH);
}

void checkLED() {
  if (bleGamepad.isConnected()) {
    ledR = 0;
    ledB = 32;
  } else {
    if (millis() >= cycleLED) {
      if (ledR < 1) {
        counterLED = 1;
      }
      if (ledR > 32) {
        counterLED = -1;
      }
      ledB = 0;
      ledR = ledR + counterLED;
      cycleLED = cycleLEDWait;
    }
  }
  pixels.setPixelColor(0, pixels.Color(ledR, ledG, ledB));
  pixels.show();
}

void shiftOut(int myDataPin, int myClockPin, byte myDataOut) {
  
  int pinState;

  pinMode(myClockPin, OUTPUT);
  pinMode(myDataPin, OUTPUT);

  digitalWrite(myDataPin, LOW);
  digitalWrite(myClockPin, LOW);

  for (int i = 7; i >= 0; i--) {
    digitalWrite(myClockPin, 0);
    if (myDataOut & (1 << i)) {
      pinState = LOW;
    } else {
      pinState = HIGH;
    }
    digitalWrite(myDataPin, pinState);
    digitalWrite(myClockPin, HIGH);
    digitalWrite(myDataPin, LOW);
  }
  digitalWrite(myClockPin, LOW);
}
