/*

Aq+ Gamepad
--------------------------------------------------------------------------------------------
by Sean P. Harrington
sph@1stage.com
aquarius.1stage.com
--------------------------------------------------------------------------------------------

Abstract -
The Aq+ Gamepad is a modern game controller for Aquarius and Aquarius+ 8-bit Z80-based 
computers. It features either wired (Mini/Micro/MX expander required for original Aquarius)
or wireless (Aquarius+) connectivity, and emulates the original Aquarius hand controller in
a form-factor that is more comfortable and fun to use.

The system was developed using an ESP32-S3-DevKitC module as the microcontroller and BLE 
(Bluetooth Low Energy) as the wireless solution. It is configured using the Arduino Core, 
and uses the "ESP32-S3-Box" board profile. Additionally, BLE connectivity is coded using 
the ESP32-BLE-Gamepad library, which itself relies on the NimBLE-Arduino library. The RGB 
LED serves as a system status indicator and uses the Adafruit NeoPixel library. All libraries 
can be loaded through the Arduino Library Manager. The system also features a LiPo 
(lithium polymer) battery, with smart charging.

--------------------------------------------------------------------------------------------

To-Do List:
 - State machine for RGB LED visual notifications
   - Charging, low battery, full, etc.
   - Paired, wired, inactive, etc.
   - Blinks for some statuses initiated by chorded button/thumbstick sequences
 - Parameterize (saved data) serial number, settings, etc.
 - USB serial/terminal interface for setting preferences (web, eventually?)
 - Create editable scaling for analog sensors
   - XY homing, and "dead zone"
   - Battery level (BATTDIV)
 - Add ability to toggle DPAD/HAT wireless output?
 - Add ability to toggle/swap 1-2-3 & 4-5-6 button rows.

Revisions:
0.2.1, 18 FEB 2025 -  Fix NeoPixel error
0.2.0, 12 FEB 2025 -  Added 1+3+5 wired chord to AQ button and changed it from BUTTON_13 to BUTTON_12 in wireless
0.1.9, 03 DEC 2024 -  Created state machine for LED/Battery
0.1.8, 30 NOV 2024 -  Remapped GPIO pin assignments after PCB rework
0.1.7, 19 NOV 2024 -  Added SettingsManagerESP32 to save persistent variables (replaces legacy EEPROM.h libarary)
0.1.6, 17 NOV 2024 -  Added battery divider sense pin
0.1.5, 17 NOV 2024 -  Switched to GPIO rather than Shift Register
0.1.4, 16 NOV 2024 -  Rework analog angle calculations from Aq+ ESP32 code
                      Created buttonByte and thumbByte to combine into dataByte
0.1.3, 11 NOV 2024 -  Shift register implemented for wired connections
                      Turn button components into arrays and loop
0.1.2, 09 NOV 2024 -  Button alignment with Xbox mappings
                      Thumbstick scaling fixed
                      Buttons transitioned to single-pin (from matrix)
0.1.1, 08 NOV 2024 -  Button matrix (unsuccessful)
0.1.0, 07 NOV 2024 -  Initial version, using Gamepad example (four buttons)
                      Installed Arduino bootloader
                      Identified compatible Board profile (ESP32-S3-Box)

Links & References -
AQP Gamepad GitHub: https://github.com/1stage/aqplus-controller
ESP32-S3_DevKitC: https://docs.espressif.com/projects/esp-dev-kits/en/latest/esp32s3/esp32-s3-devkitc-1/index.html
Arduino Core for ESP32: https://github.com/espressif/arduino-esp32
ESP32-BLE-Gamepad: https://github.com/lemmingDev/ESP32-BLE-Gamepad
Adafruit NeoPixel: https://github.com/adafruit/Adafruit_NeoPixel
NimBLE Arduino: https://github.com/h2zero/NimBLE-Arduino
SettingsManagerESP32: https://github.com/alkonosst/SettingsManagerESP32

*/

#include <Arduino.h>
#include <Adafruit_NeoPixel.h>
#include <BleGamepad.h>
#include <BleGamepadConfiguration.h>
#include <math.h>
//#include "SettingsManagerESP32.h"

#define BUTTONPIN_1 5   // ESP32 GPIO pin Aq+ button 1 is attached to
#define BUTTONPIN_2 6   // ESP32 GPIO pin Aq+ button 2 is attached to
#define BUTTONPIN_3 7   // ESP32 GPIO pin Aq+ button 3 is attached to
#define BUTTONPIN_4 8   // ESP32 GPIO pin Aq+ button 4 is attached to
#define BUTTONPIN_5 9   // ESP32 GPIO pin Aq+ button 5 is attached to
#define BUTTONPIN_6 10  // ESP32 GPIO pin Aq+ button 6 is attached to
#define BUTTONPIN_T 4   // ESP32 GPIO pin Aq+ thumbstick button is attached to
#define BUTTONPIN_G 11  // ESP32 GPIO pin Aq+ guide button is attached to

#define XPIN 15  // ESP32 GPIO pin thumbstick X is attached to
#define YPIN 16  // ESP32 GPIO pin thumbstick Y is attached to

#define BATTDIV 13  // Pin to read battery voltage level

#define RGBPIN 48  // ESP32 GPIO pin RGB LED data is attached to
#define NUMPIX 1   // Number of NeoPixel units

#define DATAPIN_0 39  // Wired data out pin 0
#define DATAPIN_1 38  // Wired data out pin 1
#define DATAPIN_2 21  // Wired data out pin 2
#define DATAPIN_3 18  // Wired data out pin 3
#define DATAPIN_4 40  // Wired data out pin 4
#define DATAPIN_5 41  // Wired data out pin 5
#define DATAPIN_6 42  // Wired data out pin 6
#define DATAPIN_7 17  // Wired data out pin 7

#define AQGP_NAME "Aq+ Gamepad"
#define AQGP_MNFR "1STAGE"
#define AQGP_BATT 100
#define AQGP_MODL "1.0"
#define AQGP_SWFM "0.1.9"
#define AQGP_HWRV "rev0"
#define AQGP_SRLN "AQGP-xxx-SPH"

// Create a NeoPixel object to control
Adafruit_NeoPixel pixels(NUMPIX, RGBPIN, NEO_GRB + NEO_KHZ800);

// Create a BleGamepad object to control
BleGamepad bleGamepad(AQGP_NAME, AQGP_MNFR, AQGP_BATT);

// Create a BleGamepadConfiguration object to store all of the options
BleGamepadConfiguration bleGamepadConfig;

// Create a state change history for all 8 buttons.
// buttonState[button_num][previous, current], HIGH = OFF
int buttonState[8][2] = { { HIGH, HIGH },
                          { HIGH, HIGH },
                          { HIGH, HIGH },
                          { HIGH, HIGH },
                          { HIGH, HIGH },
                          { HIGH, HIGH },
                          { HIGH, HIGH },
                          { HIGH, HIGH } };

struct ledColor {
  int ledR;
  int ledG;
  int ledB;
};

ledColor RED = { 32, 0, 0 };
ledColor GREEN = { 0, 32, 0 };
ledColor BLUE = { 0, 0, 32 };
ledColor CYAN = { 0, 32, 32 };
ledColor YELLOW = { 32, 32, 0 };
ledColor MAGENTA = { 32, 0, 32 };
ledColor BLACK = { 0, 0, 0 };
ledColor WHITE = { 32, 32, 32 };
ledColor ORANGE = { 32, 16, 0 };

// Create state memory for battery level:
//  1 - Battery is 50% or greater | Light is solid
//  2 - Battery is 25% to 49%     | Light pulses slowly, every (Battery Level * 400) millis()
//  3 - Battery is 10% to 24%     | Light pulses quickly, every (Battery Level * 200) millis()
//  4 - Battery is  0% to  9%     | Light is solid RED, regardless of connectivity
//  5 - Off, Battery is charging  | Dim RED glow
// batteryState[previous, current]
int batteryState[2] = { 1, 1 };

// Create state memory for connectivity:
//  1 - On, no BLE connection     | Light is MAGENTA
//  2 - On, BLE is connected      | Light is BLUE
//  3 - On, BLE connects          | Light blinks from MAGENTA to YELLOW, then to BLUE
//  4 - On, BLE disconnects       | Light blinks from BLUE to YELLOW, then to MAGENTA
//  5 - Off, Battery not charging | Light is off
// connectState[previous, current]
int connectState[2] = { 1, 1 };

int battConState[2] = { 1, 1 };

// Create a state change history for the thumbstick.
// thumbState[previous, current]
int thumbState[2] = { 0, 0 };

// Create a data pin array for wired output.
int dataPins[8] = { DATAPIN_0,
                    DATAPIN_1,
                    DATAPIN_2,
                    DATAPIN_3,
                    DATAPIN_4,
                    DATAPIN_5,
                    DATAPIN_6,
                    DATAPIN_7 };

// Create an array mapping between Aquarius buttons and BLE Gamepad buttons.
// buttonPinMap[button_num][Aq+ Button Pin, GP button]
uint8_t buttonPinMap[8][2] = { { BUTTONPIN_1, BUTTON_1 },
                               { BUTTONPIN_2, BUTTON_2 },
                               { BUTTONPIN_3, BUTTON_4 },
                               { BUTTONPIN_4, BUTTON_5 },
                               { BUTTONPIN_5, BUTTON_7 },
                               { BUTTONPIN_6, BUTTON_8 },
                               { BUTTONPIN_T, BUTTON_11 },
                               { BUTTONPIN_G, BUTTON_12 } }; // Was BUTTON_13

// Create an array for the data mappings for
// the wired output (byte mapping) for the 8 buttons.
uint8_t buttonByte[8] = { 0b01000000,
                          0b10000100,
                          0b10100000,
                          0b00100000,
                          0b10000010,
                          0b10000001,
                          0b11111111,
                          0b11100010 }; // Was 0b00000000

// Create an array for the data mappings for
// the wired output (byte mapping0 for the 16 thumbstick values
uint8_t thumbByte[17] = { 0b00000000,
                          0b00000010,
                          0b00010010,
                          0b00010011,
                          0b00000011,
                          0b00000001,
                          0b00010001,
                          0b00011001,
                          0b00001001,
                          0b00001000,
                          0b00011000,
                          0b00011100,
                          0b00001100,
                          0b00000100,
                          0b00010100,
                          0b00010110,
                          0b00000110 };


// Number of thumbstick samples to take per cycle
const int thumbSamples = 5;
// Delay in milliseconds between samples
const int delaySamples = 4;

// Persistent holder for new button data
uint8_t buttonOut = 0b00000000;
// Persistent holder for new thumbstick data
uint8_t thumbOut = 0b00000000;
// Per-cycle holder for combined button
// and thumbstick data sent to data out pins
uint8_t dataOut = 0b00000000;

// Starting battery level
// Updates from BATTDIV reading in main loop
uint8_t battLevel = 100;

// Default multiplier for milliseconds
int timeScaler = 2;
// Wait time in millis() between LED updates
int cycleLEDWait = battLevel * timeScaler;
// Holder for LED animation update timer
unsigned long cycleLED = millis() + cycleLEDWait;
// LED animation holder
int counterLED = 1;

// Holder for LED color
ledColor theLED = BLACK;

// Set up the system
void setup() {

  // Turn on the serial port.
  Serial.begin(115200);

  // Get the saved unit data and publish it to the BLE Gamepad config.
  bleGamepadConfig.setModelNumber(AQGP_MODL);
  bleGamepadConfig.setSoftwareRevision(AQGP_SWFM);
  bleGamepadConfig.setFirmwareRevision(AQGP_SWFM);
  bleGamepadConfig.setSerialNumber(AQGP_SRLN);
  bleGamepadConfig.setHardwareRevision(AQGP_HWRV);

  // Set all GPIO button pins [x][0] to INPUT_PULLUP
  // and all wired output dataPins[x] to OUTPUT.
  for (int i = 0; i < 8; i++) {
    pinMode(buttonPinMap[i][0], INPUT_PULLUP);
    pinMode(dataPins[i], OUTPUT);
  }

  // Set the battery level sensor to input (analog).
  pinMode(BATTDIV, INPUT);

  // Set the X and Y pots on the thumbstick to input (analog).
  pinMode(XPIN, INPUT);
  pinMode(YPIN, INPUT);

  // Start the BLE Gamepad.
  bleGamepad.begin();

  // Send data (blank, at start) to the wired connection.
  shiftOut(dataOut);

  // Set the initial battery level (100%).
  // It will be read and updated in the main loop.
  bleGamepad.setBatteryLevel(battLevel);

  // Setup the LED cycle timer.
  cycleLED = millis() + cycleLEDWait;

  checkBattery();
  checkConnect();
  updateLED();

  // Start up the RGB LED.
  pixels.begin();
  pixels.clear();
  theLED = BLUE;
  updateNeoPixel();
}

// Main cycle loop.
void loop() {

  checkBattery();
  checkConnect();
  updateLED();

  // Reset outbound data register each cycle loop.
  dataOut = 0b00000000;
  // Note that buttonOut and thumbOut persist through cycle loops.

  // Loop through the 8 buttons, check for changes, and apply updates
  // buttonState[button_num][0 prev, 1 curr]
  // buttonPinMap[button_num][0 GPIO, 1 GP Map]
  for (int i = 0; i < 8; i++) {
    // Set button's current logical state to its current physical state
    buttonState[i][1] = digitalRead(buttonPinMap[i][0]);
    // If the current state is different from its last state...
    if (buttonState[i][1] != buttonState[i][0]) {
      // ...if its current state is PRESSED...
      if (buttonState[i][1] == LOW) {
        // ...if there is a BLE connection, update that...
        if (bleGamepad.isConnected()) { bleGamepad.press(buttonPinMap[i][1]); };
        // ...and combine the previous button data with this button's data.
        buttonOut |= buttonByte[i];
      } else {
        // Otherwise its current state is RELEASED, so
        // if there is a BLE connection, update that...
        if (bleGamepad.isConnected()) { bleGamepad.release(buttonPinMap[i][1]); };
        // ...and remove this button's data from the previous button data.
        buttonOut &= ~buttonByte[i];
      }
    }
    // Set the previous button state to the current one.
    buttonState[i][0] = buttonState[i][1];
  }

  int XValues[thumbSamples];
  int YValues[thumbSamples];
  int XValue = 0;
  int YValue = 0;

  for (int i = 0; i < thumbSamples; i++) {
    XValues[i] = analogRead(XPIN);
    YValues[i] = analogRead(YPIN);
    XValue += XValues[i];
    YValue += YValues[i];
    delay(delaySamples);
  }

  XValue = XValue / thumbSamples;
  YValue = YValue / thumbSamples;

  // Scale up thumbstick input values to bleGamepad range
  int adjXValue = map(XValue, 0, 4095, 0, 32737);
  int adjYValue = map(YValue, 0, 4095, 0, 32737);

  // Set bleGamepad thumbstick values
  if (bleGamepad.isConnected()) {
    bleGamepad.setX(adjXValue);
    bleGamepad.setY(adjYValue);
  };

  // Scale down thumbstick X & Y values to a positive/negative
  // range for performing the trigonometric calculations.
  int dirXValue = map(XValue, 0, 4095, -2048, 2048);
  int dirYValue = map(YValue, 0, 4095, -2048, 2048);

  // Further scale X & Y values to a range of 32 values
  // for determining which of the 16 direction segments
  // they fall within.
  float x = dirXValue / 128.0f;
  float y = dirYValue / 128.0f;

  // Create a "dead zone" the middle of the thumbstick
  // when no input is being provided.
  float deadZone = sqrtf(x * x + y * y);
  // Create a traditional 0-359 degree holder for the angle.
  float angle = 0;
  // Create a variable to hold the 16 segment sector the
  // thumbstick is positioned within. The default of 0
  // indicates it's in the "dead zone".
  int p = 0;

  // Check to make sure the thumbstick is outside the "dead zone".
  if (deadZone > 1.0f) {
    // Calculate the angle and scale it.
    angle = atan2f(y, x) / (float)M_PI * 180.0f + 180.0f;
    // Calculate the sector and scale it to 1-16.
    p = ((int)((angle + 11.25) / 22.5f) + 8) % 16 + 1;
  }

  // Set the current thumbstick state to the sector.
  thumbState[1] = p;
  // If this is different from the previous sector...
  if (thumbState[1] != thumbState[0]) {
    // ...update the thumbstick output. Note that there is
    // no blending of this data from the previous state.
    thumbOut = thumbByte[thumbState[1]];
    // Set the previous thumbstick sector to the current.
    thumbState[0] = p;
  }

  // Combine button data into wired data output.
  // (Wired data was blanked at the top of the loop.)
  dataOut |= buttonOut;
  // Combine thumbstick data with the already combined
  // button data.
  dataOut |= thumbOut;

  // Write data to the wired output GPIO pins.
  shiftOut(dataOut);

    // Send out via the serial terminal for troubleshooting.
  Serial.print("bLevel=");
  Serial.print(battLevel);
  Serial.print(" : bleGamepad.isConnected=");
  Serial.print(bleGamepad.isConnected());
  Serial.print(" : bcState=");
  Serial.print(battConState[1]);
  Serial.print(" : theLED=");
  Serial.print(theLED.ledR);
  Serial.print(",");
  Serial.print(theLED.ledG);
  Serial.print(",");
  Serial.print(theLED.ledB);
  Serial.println();
  updateNeoPixel();
  // Serial.print(F("String")); // Print from string stored in FLASH memory.
}

// Manages state of Battery
void checkBattery() {
  // Read the battery level sensor and scale it from 1 to 100.
  battLevel = map(analogRead(BATTDIV), 0, 4095, 1, 139);
  // Publish this to the BLE Gamepad.
  if (bleGamepad.isConnected()) {
    bleGamepad.setBatteryLevel(battLevel);
  }

  // If the battery is 50-100%...
  if (battLevel > 49) {
    batteryState[1] = 1;
  }
  // If the battery is between 25-49%...
  if ((battLevel < 50) && (battLevel > 24)) {
    batteryState[1] = 2;
  }
  // If the battery is between 10-24%...
  if ((battLevel < 25) && (battLevel > 9)) {
    batteryState[1] = 3;
  }
  // If the battery is below 10%...
  if (battLevel < 10) {
    batteryState[1] = 4;
  }

  // Update previous state to current state.
  batteryState[0] = batteryState[1];
}

// Manages the state of Connectivity
void checkConnect() {
  // If BLE is connected...
  if (bleGamepad.isConnected()) {
    connectState[1] = 2;
  } else {
    connectState[1] = 1;
  }
  // Update previous state to current state.
  connectState[0] = connectState[1];
}

// Manages state of LED
void updateLED() {
  // Combine battery and connect states into one number.
  battConState[0] = (batteryState[0] * 10) + connectState[0];
  battConState[1] = (batteryState[1] * 10) + connectState[1];

  cycleLEDWait = battLevel * timeScaler;

  // Process every possible combination of states.
  switch (battConState[1]) {
    // Batt 50-100%, BLE NOT connected
    // Set color to a solid MAGENTA
    case 11:
      theLED = CYAN;
      batteryState[0] = 1;
      connectState[0] = 1;
      updateNeoPixel();
      break;
    // Batt 50-100%, BLE connected
    // Set color to a solid BLUE
    case 12:
      theLED = BLUE;
      batteryState[0] = 1;
      connectState[0] = 2;
      updateNeoPixel();
      break;

    // Batt 25-49%, BLE NOT connected
    // Pulse MAGENTA to BLACK to MAGENTA
    case 21:
      if (millis() >= cycleLED) {
        // See if we're at the "bottom" of the pulse cycle...
        if (theLED.ledB < 1) {
          theLED = BLACK;
          // ...and send it in the positive direction.
          counterLED = 1;
        }
        // Then see if we're at the "top" of the pulse cycle...
        if (theLED.ledB > 32) {
          theLED = MAGENTA;
          // ...and send it in the negative direction.
          counterLED = -1;
        }
        theLED.ledR += counterLED;
        theLED.ledG = 0;
        theLED.ledB += counterLED;
        cycleLED = millis() + cycleLEDWait;
      }

      // Update previous states with current states.
      batteryState[0] = 2;
      connectState[0] = 1;
      updateNeoPixel();
      break;
    // Batt 25-49%, BLE connected
    // Pulse BLUE to BLACK TO BLUE
    case 22:
      if (millis() >= cycleLED) {
        // See if we're at the "bottom" of the pulse cycle...
        if (theLED.ledB < 1) {
          theLED = BLACK;
          // ...and send it in the positive direction.
          counterLED = 1;
        }
        // Then see if we're at the "top" of the pulse cycle...
        if (theLED.ledB > 32) {
          theLED = BLUE;
          // ...and send it in the negative direction.
          counterLED = -1;
        }
        theLED.ledR = 0;
        theLED.ledG = 0;
        theLED.ledB += counterLED;
        cycleLED = millis() + cycleLEDWait;
      }

      // Update previous states with current states.
      batteryState[0] = 2;
      connectState[0] = 2;
      updateNeoPixel();
      break;

    // Batt 10-24%, BLE NOT connected
    // Pulse MAGENTA to BLACK to MAGENTA
    case 31:
      if (millis() >= cycleLED) {
        // See if we're at the "bottom" of the pulse cycle...
        if (theLED.ledB < 1) {
          theLED = BLACK;
          // ...and send it in the positive direction.
          counterLED = 1;
        }
        // Then see if we're at the "top" of the pulse cycle...
        if (theLED.ledB > 32) {
          theLED = MAGENTA;
          // ...and send it in the negative direction.
          counterLED = -1;
        }
        theLED.ledR += counterLED;
        theLED.ledG = 0;
        theLED.ledB += counterLED;
        cycleLED = millis() + cycleLEDWait;
      }

      // Update previous states with current states.
      batteryState[0] = 3;
      connectState[0] = 1;
      updateNeoPixel();
      break;
    // Batt 10-24%, BLE connected
    // Pulse BLUE to BLACK to BLUE
    case 32:
      if (millis() >= cycleLED) {
        // See if we're at the "bottom" of the pulse cycle...
        if (theLED.ledB < 1) {
          theLED = BLACK;
          // ...and send it in the positive direction.
          counterLED = 1;
        }
        // Then see if we're at the "top" of the pulse cycle...
        if (theLED.ledB > 32) {
          theLED = BLUE;
          // ...and send it in the negative direction.
          counterLED = -1;
        }
        theLED.ledR = 0;
        theLED.ledG = 0;
        theLED.ledB += counterLED;
        cycleLED = millis() + cycleLEDWait;
      }

      // Update previous states with current states.
      batteryState[0] = 3;
      connectState[0] = 2;
      updateNeoPixel();
      break;

    // Battery <10% or other untrapped errors
    // Set timer to pulse RED to BLACK to RED
    default:
      if (millis() >= cycleLED) {
        // See if we're at the "bottom" of the pulse cycle...
        if (theLED.ledR < 1) {
          theLED = BLACK;
          // ...and send it in the positive direction.
          counterLED = 1;
        }
        // Then see if we're at the "top" of the pulse cycle...
        if (theLED.ledR > 32) {
          theLED = RED;
          // ...and send it in the negative direction.
          counterLED = -1;
        }
        theLED.ledR += counterLED;
        theLED.ledG = 0;
        theLED.ledB = 0;
        cycleLED = millis() + cycleLEDWait;
      }

      // Update previous states with current states.
      batteryState[0] = batteryState[1];
      connectState[0] = connectState[1];
      battConState[0] = battConState[1];
      updateNeoPixel();
      break;
  }
}

void updateNeoPixel() {
  // Update the RGB LED values...
  pixels.setPixelColor(0, theLED.ledR, theLED.ledG, theLED.ledB);
  // pixels.setPixelColor(0,0,0,32);
  // ...and publish them to the device.
  pixels.show();
}

// Takes a byte and assigns its bits to individual
// GPIO pins for the wired connection.
void shiftOut(byte myDataOut) {
  // Start at the MSB/high bit, and work down.
  for (int i = 7; i >= 0; i--) {

    // This next section may seem contradictory, but the myDataOut bits
    // represent a byte in traditional binary format, where 1=ON/HIGH/TRUE
    // and 0=OFF/LOW/FALSE, but they are presented electronically on the
    // GPIO pins in the inverse, where 1=OFF/LOW/FALSE and 0=ON/HIGH/TRUE.

    // So, if the saved bit and current bit are 1...
    if (myDataOut & (1 << i)) {
      // ...set that GPIO pin/bit to LOW.
      digitalWrite(dataPins[i], LOW);
      // Otherwise...
    } else {
      // ...set that GPIO pin/bit to HIGH.
      digitalWrite(dataPins[i], HIGH);
    }
  }
}
