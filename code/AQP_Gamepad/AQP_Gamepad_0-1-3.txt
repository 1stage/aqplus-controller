/*

Aq+ Gamepad
--------------------------------------------------------------------------------------------
by Sean P. Harrington
sph@1stage.com
aquarius.1stage.com
--------------------------------------------------------------------------------------------

Abstract -
The Aq+ Gamepad is a modern game controller for Aquarius and Aquarius+ 8-bit Z80-based 
computers. It features either wired (Mini/Micro/MX expander required for original Aquarius)
or wireless (Aquarius+) connectivity, and emulates the original Aquarius hand controller in
a form-factor that is more comfortable and fun to use.

The system was developed using an ESP32-S3-DevKitC module as the microcontroller and BLE 
(Bluetooth Low Energy) as the wireless solution. It is configured using the Arduino Core, 
and uses the "ESP32-S3-Box" board profile. Additionally, BLE connectivity is coded using 
the ESP32-BLE-Gamepad library, which itself relies on the NimBLE-Arduino library. The RGB 
LED serves as a system status indicator and uses the Adafruit NeoPixel library. All libraries 
can be loaded through the Arduino Library Manager. The system also features a LiPo 
(lithium polymer) battery, with smart charging.

--------------------------------------------------------------------------------------------

Revisions:
0.1.3, 11 NOV 2024 -  Shift register implemented for wired connections
                      Turn button components into arrays and loop
0.1.2, 09 NOV 2024 -  Button alignment with Xbox mappings
                      Thumbstick scaling fixed
                      Buttons transitioned to single-pin (from matrix)
0.1.1, 08 NOV 2024 -  Button matrix (unsuccessful)
0.1.0, 07 NOV 2024 -  Initial version, using Gamepad example (four buttons)
                      Installed Arduino bootloader
                      Identified compatible Board profile (ESP32-S3-Box)

Links & References -
AQP Gamepad GitHub: https://github.com/1stage/aqplus-controller
ESP32-S3_DevKitC: https://docs.espressif.com/projects/esp-dev-kits/en/latest/esp32s3/esp32-s3-devkitc-1/index.html
Arduino Core for ESP32: https://github.com/espressif/arduino-esp32
ESP32-BLE-Gamepad: https://github.com/lemmingDev/ESP32-BLE-Gamepad
Adafruit NeoPixel: https://github.com/adafruit/Adafruit_NeoPixel
NimBLE Arduino: https://github.com/h2zero/NimBLE-Arduino

*/

#include <Arduino.h>
#include <Adafruit_NeoPixel.h>
#include <BleGamepad.h>
#include <BleGamepadConfiguration.h>

#define BUTTONPIN_1 5   // ESP32 GPIO pin Aq+ button 1 is attached to
#define BUTTONPIN_2 6   // ESP32 GPIO pin Aq+ button 2 is attached to
#define BUTTONPIN_3 7   // ESP32 GPIO pin Aq+ button 3 is attached to
#define BUTTONPIN_4 8   // ESP32 GPIO pin Aq+ button 4 is attached to
#define BUTTONPIN_5 9   // ESP32 GPIO pin Aq+ button 5 is attached to
#define BUTTONPIN_6 10  // ESP32 GPIO pin Aq+ button 6 is attached to
#define BUTTONPIN_T 4   // ESP32 GPIO pin Aq+ thumbstick button is attached to
#define BUTTONPIN_G 11  // ESP32 GPIO pin Aq+ guide button is attached to

#define XPIN 15  // ESP32 GPIO pin thumbstick X is attached to
#define YPIN 16  // ESP32 GPIO pin thumbstick Y is attached to

#define RGBPIN 48  // ESP32 GPIO pin RGB LED data is attached to
#define NUMPIX 1   // Number of NeoPixel units

#define SR_DATA 12   // ESP32 GPIO pin Shift Register Data pin is attached to
#define SR_CLK 13    // ESP32 GPIO pin Shift Register Clock pin is attached to
#define SR_LATCH 14  // ESP32 GPIO pin Shift Register Latch pin is attached to

#define AQGP_NAME "Aq+ Gamepad"
#define AQGP_MNFR "1STAGE"
#define AQGP_BATT 100
#define AQGP_MODL "1.0"
#define AQGP_SWFM "0.1.3"
#define AQGP_HWRV "rev0"
#define AQGP_SRLN "AQGP-xxx-SPH"

Adafruit_NeoPixel pixels(NUMPIX, RGBPIN, NEO_GRB + NEO_KHZ800);  // Create a NeoPixel object to control

BleGamepad bleGamepad(AQGP_NAME, AQGP_MNFR, AQGP_BATT);  // Create a BleGamepad object to control

BleGamepadConfiguration bleGamepadConfig;  // Create a BleGamepadConfiguration object to store all of the options

unsigned long cycleButtons;        // Timer to clear Buttons
const int cycleButtonsWait = 250;  // Wait time between Buttons

// buttonState[button_num][previous, current], HIGH = OFF
int buttonState[8][2] = { { HIGH, HIGH },
                          { HIGH, HIGH },
                          { HIGH, HIGH },
                          { HIGH, HIGH },
                          { HIGH, HIGH },
                          { HIGH, HIGH },
                          { HIGH, HIGH },
                          { HIGH, HIGH } };

// buttonPinMap[button_num][Aq+ Button Pin, GP button]
uint8_t buttonPinMap[8][2] = { { BUTTONPIN_1, BUTTON_1 },
                               { BUTTONPIN_2, BUTTON_2 },
                               { BUTTONPIN_3, BUTTON_4 },
                               { BUTTONPIN_4, BUTTON_5 },
                               { BUTTONPIN_5, BUTTON_7 },
                               { BUTTONPIN_6, BUTTON_8 },
                               { BUTTONPIN_T, BUTTON_11 },
                               { BUTTONPIN_G, BUTTON_13 } };

// byte mappings for buttons
uint8_t buttonByte[8] = { 0b01000000,
                          0b10000100,
                          0b10100000,
                          0b00100000,
                          0b10000010,
                          0b10000001,
                          0b11111111,
                          0b00000000 };

uint8_t dataOut;
uint8_t dataHold;

bool buttonDown = 0;

const float Pi = 3.14159;

unsigned long cycleThumb;        // Reset timer to clear Thumb
const int cycleThumbWait = 250;  // Wait time between Thumb cycles

const int thumbSamples = 5;  // Number of thumbstick samples to take
const int delaySamples = 4;  // Delay in milliseconds between samples

unsigned long cycleLED;       // LED animation update timer
const int cycleLEDWait = 50;  // Wait time between LED cycles
int counterLED = 1;

uint8_t ledR = 0;
uint8_t ledG = 0;
uint8_t ledB = 0;

void setup() {

  bleGamepadConfig.setModelNumber(AQGP_MODL);
  bleGamepadConfig.setSoftwareRevision(AQGP_SWFM);
  bleGamepadConfig.setFirmwareRevision(AQGP_SWFM);
  bleGamepadConfig.setSerialNumber(AQGP_SRLN);
  bleGamepadConfig.setHardwareRevision(AQGP_HWRV);

  // Set all GPIO button pins [x][0] to INPUT_PULLUP
  for (int i = 0; i < 8; i++) {
    pinMode(buttonPinMap[i][0], INPUT_PULLUP);
  }

  pinMode(XPIN, INPUT);
  pinMode(YPIN, INPUT);

  pinMode(SR_DATA, OUTPUT);
  pinMode(SR_CLK, OUTPUT);
  pinMode(SR_LATCH, OUTPUT);

  bleGamepad.begin();

  dataHold = 0b00000000;  // Latched data
  dataOut = 0b00000000;   // New data

  // Hold latch pin LOW while transmitting
  digitalWrite(SR_LATCH, LOW);
  // Send data
  shiftOut(SR_DATA, SR_CLK, dataOut);
  // Set latch pin HIGH when done
  digitalWrite(SR_LATCH, HIGH);
  // Save latched data

  cycleButtons = millis() + cycleButtonsWait;
  cycleThumb = millis() + cycleThumbWait;

  cycleLED = millis() + cycleLEDWait;
  pixels.begin();
  pixels.clear();
  pixels.setPixelColor(0, pixels.Color(ledR, ledG, ledB));
  pixels.show();
}

void loop() {

  checkLED();

  // buttonState[button_num][0 prev, 1 curr]
  // buttonPinMap[button_num][0 GPIO, 1 GP Map]
  for (int i = 0; i < 8; i++) {
    buttonDown = 0;
    buttonState[i][1] = digitalRead(buttonPinMap[i][0]);
    if (buttonState[i][1] != buttonState[i][0]) {
      if (buttonState[i][1] == LOW) {
        if (bleGamepad.isConnected()) { bleGamepad.press(buttonPinMap[i][1]); };
        buttonDown = 1;
        dataOut = dataOut | buttonByte[i];
      } else {
        if (bleGamepad.isConnected()) { bleGamepad.release(buttonPinMap[i][1]); };
        dataOut = dataOut ^ buttonByte[i];
      }
    }
    buttonState[i][0] = buttonState[i][1];
  }

  if (buttonDown) {
    cycleButtons = millis() + cycleButtonsWait;
  } else {
    if (millis() > cycleButtons) {
      dataOut = dataHold & 0b00011000;
      cycleButtons = millis() + cycleButtonsWait;
    }
  }

  int XValues[thumbSamples];
  int YValues[thumbSamples];
  int XValue = 0;
  int YValue = 0;

  for (int i = 0; i < thumbSamples; i++) {
    XValues[i] = analogRead(XPIN);
    YValues[i] = analogRead(YPIN);
    XValue += XValues[i];
    YValue += YValues[i];
    delay(delaySamples);
  }

  XValue = XValue / thumbSamples;
  YValue = YValue / thumbSamples;

  int adjXValue = map(XValue, 0, 4095, 0, 32737);
  int adjYValue = map(YValue, 0, 4095, 0, 32737);

  if (bleGamepad.isConnected()) {
    bleGamepad.setX(adjXValue);
    bleGamepad.setY(adjYValue);
  };

  // Hold latch pin LOW while transmitting
  digitalWrite(SR_LATCH, LOW);
  // Send data
  shiftOut(SR_DATA, SR_CLK, dataOut);
  // Set latch pin HIGH when done
  digitalWrite(SR_LATCH, HIGH);
  // Store latched Data
  dataHold = dataOut;

}

void checkLED() {
  if (bleGamepad.isConnected()) {
    ledR = 0;
    ledB = 32;
  } else {
    if (millis() >= cycleLED) {
      if (ledR < 1) {
        counterLED = 1;
      }
      if (ledR > 32) {
        counterLED = -1;
      }
      ledB = 0;
      ledR = ledR + counterLED;
      cycleLED = cycleLEDWait;
    }
  }
  pixels.setPixelColor(0, pixels.Color(ledR, ledG, ledB));
  pixels.show();
}

void shiftOut(int myDataPin, int myClockPin, byte myDataOut) {
  // This shifts 8 bits out MSB first,
  //on the rising edge of the clock,
  //clock idles low
  //internal function setup
  int pinState;
  pinMode(myClockPin, OUTPUT);
  pinMode(myDataPin, OUTPUT);

  //clear everything out just in case to
  //prepare shift register for bit shifting
  digitalWrite(myDataPin, LOW);
  digitalWrite(myClockPin, LOW);
  //for each bit in the byte myDataOut&#xFFFD;
  //NOTICE THAT WE ARE COUNTING DOWN in our for loop
  //This means that %00000001 or "1" will go through such
  //that it will be pin Q0 that lights.
  for (int i = 7; i >= 0; i--) {
    digitalWrite(myClockPin, 0);
    //if the value passed to myDataOut and a bitmask result
    // true then... so if we are at i=6 and our value is
    // %11010100 it would the code compares it to %01000000
    // and proceeds to set pinState to 1.
    if (myDataOut & (1 << i)) {
      pinState = LOW;
    } else {
      pinState = HIGH;
    }
    //Sets the pin to HIGH or LOW depending on pinState
    digitalWrite(myDataPin, pinState);
    //register shifts bits on upstroke of clock pin
    digitalWrite(myClockPin, HIGH);
    //zero the data pin after shift to prevent bleed through
    digitalWrite(myDataPin, LOW);
  }
  //stop shifting
  digitalWrite(myClockPin, LOW);
}
